# Spring DB1편

### 커넥션풀에 대한 이해
정의 : 사용자는 TCP/IP 3way-handshake 과정을 진행하고 SQL구문을 수행한 이후에 결과값을 볼 수 있다. 여기서 시간지연이 발생하는데 이 문제를
해결하기 위해서 미리 연결을 생성해놓고 하고 사용하는 방법이다.

#### 특징
- 커넥션 풀은 서버당 최대 커넥션 수를 제한하는게 가능하다.
- 커넥션 풀은 한개만 있는게 아닌 여러개가 존재하는데 갑자기 다른 걸 사용하려면 애플리케이션 로직을 변경해야 할 수 있다. -> Datasource interface로 해결
- 커넥션 생성 작업은 실행 속도에 영향을 주지 않기 위해서 별도의 쓰레드에서 동작한다.
#### Driver Manager 과 DataSource로 연결을 얻어올 때 차이
- Driver Manager는 URL, USERNAME, PASSWORD같은 파라미터를 계속 전달해야 하지만 DataSource는 객체 생성시 한번만 주고 이후에는 메소드로 사용이 가능하다.


### 트랜잭션
정의 : 데이터베이스를 사용하는 이유 중 하나로 하나의 거래를 안전하게 처리하도록 보장해준다.
- 비즈니스 로직이 있는 서비스 계층에서 시작해야 한다.-> 비즈니스 로직이 잘못되면 해당 비즈니스 로직으로 인해 문제가 되는 부분을 함께 롤백해야 하기 때문에
- 트랜잭션 사용하는 동안 같은 커넥션을 유지해야 한다.
#### 용어 정리 
- 커밋(Commit) : 모든 작업이 성공해서 데이터베이스에 반영하는 것. 커밋 호출 전까지는 임시로 데이터를 저장하고 있는다.
  - 자동 커밋과 수동 커밋을 지정하는게 가능하고 한번 설정하면 계속 유지된다.
- 롤백(Rollback) : 작업 중하나라도 실패해서 거래 이전으로 되돌림.

#### 트랜잭션 ACID
- 원자성(Atomicity)
- 일관성(Consistency)
- 격리성(Isolation)
- 지속성(Durability)

#### 트랜잭션 격리 수준
- READ UNCOMMITED(커밋되지 않은 읽기)
- READ COMMITED(커밋된 읽기)
- REPEATABLE READ(반복 가능한 읽기)
- SERIALIZABLE(직렬화 기능)

### 락
- 아직 세션이 끝나지 않았는데 다른 세션이 똑같은 데이터를 수정하게 된다면 문제가 발생한다. 그래서 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋 또는 록백 전까지 다른 세션에서 데이터를 수저할 수 없어야 한다.
- 이런 상황에서 락을 이용해 해결한다.
- 일반적인 조회는 락을 사용하지 않는다.

### 순수한 서비스 계층
- 서비스 계층은 기술에 의존하지 않게 구현하는게 중요하다. -> 기술이 바뀔때 마다 계속 바꿔야 할 수도 있음.
- SQLException도 JDBC기술에 의존하는 거라서 없어지게 하는게 좋다. -> 만약 JPA로 바꾸면 오류가 발생할 수 있다
- 문제들을 해결하기 위해서 인터페이스를 이용해 추상화하는게 좋다. -> 트랜잭션 매니저


### 트랜잭션 템플릿
- 탬플릿 콜백 패턴을 적용하려면 탬플릿을 제공하는 클래스를 작성해야 한다. 스프링은 TransactionTemplate라는 템플릿 클래스를 제공한다.
- 비즈니스 로직이 정상 수행되면 커밋한다.
- 언체크 예외가 발생하면 롤백한다.

### 선언적 트랜잭션 관리 vs 프로그래밍 방식 트랜잭션 관리
- 선언적 트랜잭션 @Transaction 을 사용해서 선언하는 방법인데 프로그래밍 방식에 비해 매우 간단해서 실무에서 많이 사용된다.


### 예외
- 상위 예외를 catch로 잡으면 그 하위 예외까지 함께 잡는다. -> Throw를 할때 하위 예외까지 같이 던지는 경우가 발생할 수 있다.
- Throwable -> Error, Exception 으로 나눠진다.
- Exception -> 체크 예외, 언체크 예외(런타임 예외) 로 나눠진다.
- 체크 예외를 밖으로 던지는 경우에도 해당 타입과 그 하위 타입을 모두 던지는게 가능하다.
- 체크 예외는 반드시 던지거나 처리해야 한다 -> 안그러면 컴파일 오류 발생
- 언체크 예외는 throws 를 선언하지 않아도 자동으로 던진다.
- 예외를 전환할 때는 꼭 기존예외를 포함하자.

#### 체크 예외 VS 언체크 예외
- 체크 예외는 throws를 무조건 선언해줘야 한다.
- 체크 예외는 무조건 처리를 해줘야 하지만 언체크 예외는 무시하고 지나갈 수 있다.
- 언체크 예외는 개발자가 실수로 예외를 누락시킬 수 있디만 체크 예외는 반드시 처리를 해줘야 해서 누락시키지 않을 수 있다.
- 체크 예외를 제대로 처리하지 못하면 배포한 상태에서는 해당 문제를 수정할때 까지 계속 문제가 동일하게 발생한다.
- 언체크 예외는 런타임 예외라서 서비스, 컨트롤러는 처리할 수 없다면 별도의 선언 없이 그냥 두면 된다.

#### 예외 규칙
- 예외는 잡아서 처리하거나 던져야 한다.
- 예외를 잡거나 던질 때 지정한 예외뿐 아니라 예외의 자식들도 함께 처리된다.
